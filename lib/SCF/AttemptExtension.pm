#####################################################
#
#    Package: SCF::AttemptExtension
#
# CF: AttemptExtension
#
# Options:
#
# How It Works:
#
# Thought/Codelets Scheduled:
#
#####################################################
#   
#####################################################

package SCF::AttemptExtension;
use strict;
use Carp;
use Smart::Comments;
use English qw(-no_match_vars);
use SCF;

use Class::Multimethods;
multimethod 'find_reln';
multimethod 'apply_reln';
multimethod 'plonk_into_place';
use base qw{};

{
    my ($logger, $is_debug, $is_info);
    BEGIN{ $logger   = Log::Log4perl->get_logger("SCF::AttemptExtension"); 
           $is_debug = $logger->is_debug();
           $is_info  = $logger->is_info();
         }
    sub LOGGING_DEBUG() { $is_debug; }
    sub LOGGING_INFO()  { $is_info;  }
}

my $logger = Log::Log4perl->get_logger("SCF::AttemptExtension"); 


# method: run
# 
#
sub run{
    my ( $action_object, $opts_ref ) = @_;
        if (LOGGING_INFO()) {
        my $msg = $action_object->generate_log_msg();

        $logger->info( $msg );
    }
    ################################
    ## Code above autogenerated.
    ## Insert Code Below

    ## AttemptExtension

    my $core = $opts_ref->{core} or confess "need core";
    my $direction = $opts_ref->{direction} or confess "need direction";

    my $direction_of_core = $core->get_direction;
    my $type = $core->isa('SObject') ? "object" : "reln";

    ## $direction, $direction_of_core, $type

    my ( $reln, $obj1, $obj2, $next_pos, $what_next );
    if ($direction == $direction_of_core) {
        if ($type eq "reln") {
            ($reln, $obj1, $obj2 ) = ($core, $core->get_ends );
        } else {
            $reln = $core->get_underlying_reln() or return;
            $obj2 = $core->[-1];
        }
    } else {
        if ($type eq "reln") {
            ($reln, $obj2, $obj1 ) = ($core->get_inverse, $core->get_ends );
        } else {
            $reln = $core->get_underlying_reln()->get_inverse() or return;
            $obj2 = $core->[0];
        }
    }

    $next_pos = $obj2->get_next_pos_in_dir( $direction );
    return unless $next_pos;

    $what_next = apply_reln( $reln, $obj2 ) or return;

    my $core_span = $core->get_span;
    
    # Check that this is what is present...
    my $is_this_what_is_present;
    eval {$is_this_what_is_present= 
              SWorkspace->check_at_location({ start => $next_pos,
                                              direction => $direction,
                                              what => $what_next,
                                          }
                                                );
      };

    if ($EVAL_ERROR) {
        my $err = $EVAL_ERROR;
        #main::message("Good! Error caught");
        if (UNIVERSAL::isa($err, "SErr::AskUser")) {
            my $already_matched = $err->already_matched();
            my $ask_if_what = $err->next_elements();
            #main::message("already_matched @$already_matched; span = $core_span");
            if (worth_asking($already_matched, $ask_if_what, $core_span)) {
                # main::message("We may ask the user if the next elements are: @$ask_if_what");
                my $ans = main::ask_user($ask_if_what);
                if ($ans) {
                    SWorkspace->insert_elements( @$ask_if_what );
                } else {
                    $core->set_right_extendibility( EXTENDIBILE::NO());
                }
            } else {
                #main::message("decided not to ask if next are @$ask_if_what");
            }
            return;
        } else {
            $err->rethrow;
        }
    }
    if ($is_this_what_is_present) {
        my $wso = plonk_into_place($next_pos, 
                                   $direction,
                                   $what_next
                                       );
        my $reln_to_add;
        if ($direction == $direction_of_core) {
            $reln_to_add = find_reln($obj2, $wso);
        } else {
            $reln_to_add = find_reln($wso, $obj2);
        }
        $reln_to_add->insert;

        if ($type eq "object") {
            my $core_object_ref = $core->get_parts_ref();
            if ($direction == $direction_of_core) {
                push @$core_object_ref, $wso;
            } else {
                unshift @$core_object_ref, $wso;
            }
            $core->recalculate_edges();
        }
        # main::message("Okay, extended");
    } else {
        # maybe attempt extension
        if (SUtil::toss(0.5)) {
            return;
        } else {
            if ($type eq 'object') {
                # ???
            } else {
                my $tht = new SThought::AreTheseGroupable
                    ( { items => [$obj1, $obj2],
                        reln  => $core
                    });
                ContinueWith( $tht );
            }
        }
    }

}

sub worth_asking{
    my ( $matched, $unmatched, $extension_from_span ) = @_;
    ## $matched
    ## $unmatched
    my $penetration = (scalar(@$matched) + $extension_from_span) / $SWorkspace::elements_count;
    ## $penetration
    return unless $penetration;

    my $on_a_limb = scalar(@$unmatched)/(scalar(@$matched) + $extension_from_span);
    return 1 if ($penetration > 0.3 and $on_a_limb < 0.8);
    return;
}

1;
