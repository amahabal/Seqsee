#####################################################
#
#    Package: SCF::FindIfRelatedRelns
#
# CF: FindIfRelatedRelns
#
# Options:
#
# How It Works:
#
# Thought/Codelets Scheduled:
#
#####################################################
#   
#####################################################

package SCF::FindIfRelatedRelns;
use strict;
use Carp;
use Smart::Comments;
use English qw(-no_match_vars);

use Class::Multimethods;

use base qw{};

multimethod "are_relns_compatible";

{
    my ($logger, $is_debug, $is_info);
    BEGIN{ $logger   = Log::Log4perl->get_logger("SCF::FindIfRelatedRelns"); 
           $is_debug = $logger->is_debug();
           $is_info  = $logger->is_info();
         }
    sub LOGGING_DEBUG() { $is_debug; }
    sub LOGGING_INFO()  { $is_info;  }
}

my $logger = Log::Log4perl->get_logger("SCF::FindIfRelatedRelns"); 


# method: run
# 
#
sub run{
    my ( $action_object, $opts_ref ) = @_;
        if (LOGGING_INFO()) {
        my $msg = $action_object->generate_log_msg();

        $logger->info( $msg );
    }
    ################################
    ## Code above autogenerated.
    ## Insert Code Below
    my $a = $opts_ref->{a};
    my $b = $opts_ref->{b};
    my ($af, $as, $bf, $bs) = ($a->get_ends(), $b->get_ends());
    
    # check if there is any intersection at all
    my %edge_hash;
    my $hit;
    for ($af, $as, $bf, $bs) { 
        my $count = ++$edge_hash{$_};
        $hit = $_ if $count > 1;
    }
    return unless $hit;

    # It could be that af=bf or as=bs, which'd mean that we may want to flip one of them.
    # or it could be that bs=af, in which case their roles will need to be switched

    if ($af eq $bf or $as eq $bs) {
        # choose one of these to flip
        # XXX weaker!!
        my $maybe_check_flippability = SChoose->choose([$a, $b]);
        my $tht = SThought::ShouldIFlip->new({reln => $maybe_check_flippability});
        SErr::NeedMoreData->new(payload => $tht)->throw()
    }

    if ($af eq $bs) { # need to flip roles!
        ($a, $b, $af, $bf, $as, $bs) = ($b, $a, $bf, $af, $bs, $as);
    }

    # Must be teh case that as is bf. Now we need to see if they are compatible
    my $compatibility = are_relns_compatible($a, $b);
    if ($compatibility) {
        my $tht = SThought::AreTheseGroupable->new({items => [$af, $as, $bs]});
        SErr::NeedMoreData->new(payload=> $tht)->throw();
    }
}
1;
