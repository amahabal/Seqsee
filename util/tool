#!/usr/bin/perl -w
use IO::Prompt;
use blib;
use S;
use SUtil;

# Tool to do a lot of things...

my $command;
my $MENU 
    = { "Remove Log Files"         => 'log#clean',
        "Archive Current Log File" => 'log#archive', 
        "New Codefamily"           => 'cf#new',
        "New Thought"              => 'tf#new',
    }; 

my $ACTIONS_ref 
    = { 'log#clean'   => \&logs_clean,
        'log#archive' => \&logs_archive,
        'cf#new'      => \&cf_new,
        'tf#new'      => \&tf_new,
    };

if (@ARGV) {
    $command = join("#", @ARGV);
} else {
    $command = prompt( -menu => $MENU );
}

my $action = $ACTIONS_ref->{ $command };

die "Don't know how to '$command'" unless $action;
$action->();



#### method logs_clean
# description    :gets rid of all the logs in the log/ directory (though not the archive directory)
# argument list  :
# return type    :
# context of call:
# exceptions     :

sub logs_clean {
    for my $file (glob("log/*log"), "log/latest") {
        unlink($file);
    }
}


#### method logs_archive
# description    :copies the 'latest' log into theh archive, renumbering appropriately
# argument list  :
# return type    :
# context of call:
# exceptions     :

sub logs_archive{
    my $latest_filenumber = SUtil::next_available_file_number("log") - 1;
    die q{No "latest" file: so cannot archive!"} unless $latest_filenumber;
    my $latest_file = "log/$latest_filenumber.log";
    my $newfilenum = SUtil::next_available_file_number("log/archive");
    my $newfilename = "log/archive/$newfilenum.log";
    system "cp $latest_file $newfilename";
}


#### method cf_new
# description    :Starts a new codefamily; writes a start file, adds name to SCF.list etc
# argument list  :
# return type    :
# context of call:
# exceptions     :

sub cf_new{
    my $family_name = prompt "Name of codefamily: ", -require => { 'Name of codefamily should only have a-zA-Z_' => qr{^[a-zA-Z][a-zA-Z_]+$} };
    

    my $filename = "lib/SCF/$family_name.pm";

    if (-e $filename) {
        die "File $filename already exists: won't overwrite!";
    }
    
    my $package_name = "SCF::$family_name";
    
    open my $out, ">", $filename;
    print {$out} << "PM_FILE";

package $package_name;
{
    my (\$logger, \$is_debug, \$is_info);
    BEGIN{ \$logger   = Log::Log4perl->get_logger("$package_name"); 
           \$is_debug = \$logger->is_debug();
           \$is_info  = \$logger->is_info();
         }
    sub LOGGING_DEBUG() { \$is_debug; }
    sub LOGGING_INFO()  { \$is_info;  }
}

my \$logger = Log::Log4perl->get_logger("$package_name"); 
sub run{
    my \$action_object  = shift;
    my \$opts_ref       = shift;
    if (LOGGING_INFO()) {
        my \$msg = \$action_object->generate_log_msg();

        \$logger->info( \$msg );
    }
    ################################
    ## Code above autogenerated.
    ## Insert Code Below
    

}

1;
PM_FILE

    close $out;

    my $add_to_list = prompt "Should I add this to the SCF.list? ", "-yn";
    if ($add_to_list) {
        open my $out, ">>", "SCF.list";
        print {$out} "\n$package_name\n";
        close $out;
    }

}

sub tf_new{
    my $thought_name = prompt "Name of thought: ", -require => { 'Name of thought should only have a-zA-Z_' => qr{^[a-zA-Z][a-zA-Z_]+$} };
    my $filename = "lib/SThought/$thought_name.pm";

    if (-e $filename) {
        die "File $filename already exists: won't overwrite!";
    }

    print "Writing to '$filename'";
    open my $out, ">", $filename;
    
    my $package_name = "SThought::$thought_name";

    my $one_line_desc = prompt "One line description: ";
    my $has_core = prompt -yn => "Does this thought type have a core?";

    my $core_v = $has_core ? "# variable: \%core_of\n#  The Core\nmy \%core_of :ATTR()" : "";
    my $core_build_line = $has_core ? "  my \$core = \$core_of{\$id} = \$opts_ref->{core} or confess \"Need core\";" : "";

    print {$out} << "PM_FILE";
#####################################################
#
#    Package: $package_name
#
#####################################################
#   $one_line_desc
#####################################################
package $package_name;
use strict;
use Carp;
use Class::Std;
use Class::Multimethods;
use base qw{SThought};


$core_v

# method: BUILD
# Builds
#
sub BUILD{
    my ( \$self, \$id, \$opts_ref ) = \@_;
$core_build_line
}

# method: get_fringe
# 
#
sub get_fringe{
    my ( \$self ) = \@_;
    my \$id = ident \$self;
    my \@ret;

    return \\\@ret;
}

# method: get_extended_fringe
# 
#
sub get_extended_fringe{
    my ( \$self ) = \@_;
    my \$id = ident \$self;
    my \@ret;

    return \\\@ret;
}

# method: get_actions
# 
#
sub get_actions{
    my ( \$self ) = \@_;
    my \$id = ident \$self;
    my \@ret;

    return \@ret;
}

# method: as_text
# textual representation of thought
sub as_text{
    my ( \$self ) = \@_;
    my \$id = ident \$self;

    return "$package_name ";
}

1;
PM_FILE

}
